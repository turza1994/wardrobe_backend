{"file_contents":{"drizzle.config.ts":{"content":"import type { Config } from 'drizzle-kit';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nexport default {\n  schema: './src/db/schema.ts',\n  out: './drizzle',\n  dialect: 'postgresql',\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n} satisfies Config;\n","size_bytes":265},"replit.md":{"content":"# ShareWardrobe Backend API\n\n## Project Overview\nShareWardrobe is a professional backend service for a peer-to-peer fashion marketplace built with Node.js, Express.js, TypeScript, and Drizzle ORM. The system enables users to buy, sell, and rent fashion items with complete transaction management, delivery tracking, and rental lifecycle management.\n\n## Architecture\n\n### Key Design Principles\n- **Pluggable Services**: All external integrations (auth, storage, payment, delivery, notifications, background jobs) use interface-based design for easy swapping\n- **Type Safety**: Full TypeScript coverage with Zod runtime validation\n- **Error Handling**: Centralized error middleware with request ID tracking for observability\n- **Database**: PostgreSQL with Drizzle ORM, includes check constraints, indexes, and soft deletes\n- **Security**: JWT authentication, RBAC, rate limiting, helmet security headers\n\n### Pluggable Service Architecture\n\n#### 1. **Authentication** (Currently: JWT, Future: Keycloak)\n- Interface: `IAuthService` in `src/services/auth/authService.interface.ts`\n- Current: `JWTAuthService` using jsonwebtoken\n- To switch to Keycloak: Implement `IAuthService` and swap in `src/services/auth/index.ts`\n\n#### 2. **File Storage** (Currently: Local, Future: MinIO)\n- Interface: `IStorageService` in `src/services/storage/storageService.interface.ts`\n- Current: `LocalStorageService` stores files in `./uploads` directory\n- To switch to MinIO: Implement `IStorageService` with MinIO client and swap in `src/services/storage/index.ts`\n\n#### 3. **Background Jobs** (Currently: In-Memory, Future: Redis + BullMQ)\n- Interface: `IJobService` in `src/services/jobs/jobService.interface.ts`\n- Current: `InMemoryJobService` logs job info (no actual execution)\n- To switch to Redis + BullMQ: Implement `IJobService` with BullMQ and swap in `src/services/jobs/index.ts`\n\n#### 4. **Notifications** (Currently: In-App, Future: Email/SMS/Socket.io)\n- Interface: `INotificationService` in `src/services/notification/notificationService.interface.ts`\n- Current: `InAppNotificationService` saves to database only\n- To add Email/SMS: Implement methods in service or create new service implementing `INotificationService`\n\n#### 5. **Payment Gateway** (Currently: Mock, Future: Bkash/Stripe)\n- Interface: `IPaymentService` in `src/services/payment/paymentService.interface.ts`\n- Current: `MockPaymentService` logs payment info\n- To integrate Bkash/Stripe: Implement `IPaymentService` and swap in `src/services/payment/index.ts`\n\n#### 6. **Delivery** (Currently: Mock, Future: Pathao)\n- Interface: `IDeliveryService` in `src/services/delivery/deliveryService.interface.ts`\n- Current: `MockDeliveryService` logs delivery info\n- To integrate Pathao: Implement `IDeliveryService` and swap in `src/services/delivery/index.ts`\n\n## Database Schema\n\n### Core Tables\n- **users**: User accounts with roles (user, seller, user_seller, admin), balances, NID verification\n- **categories**: Item categories\n- **items**: Items for sale/rent with images, prices, quantities, and statuses\n- **cart_items**: Shopping cart with negotiated prices and expiration\n- **orders**: Orders with payment method, delivery charges, safety deposits\n- **order_items**: Individual items in orders\n- **negotiations**: Price negotiation history\n- **deliveries**: Delivery tracking with return flags\n- **rentals**: Rental lifecycle with late fees and return inspection\n- **transactions**: All financial movements (payment, refund, withdrawal, fee)\n- **withdrawal_requests**: Seller withdrawal requests\n- **notifications**: In-app notifications\n- **warehouse_inventory**: Warehouse stock management\n- **admin_configs**: Dynamic platform configuration\n\n### Key Features\n- **Soft Deletes**: All tables have `deletedAt` for data retention\n- **Partial Unique Indexes**: Email unique only when not deleted\n- **Check Constraints**: Enforce business rules (e.g., quantity >= 1, prices >= 0)\n- **Indexes**: On foreign keys and commonly filtered columns for performance\n\n## API Endpoints\n\n### Health Checks\n- `GET /api/v1/health` - Full health check with database\n- `GET /api/v1/health/ready` - Readiness check\n- `GET /api/v1/health/live` - Liveness check\n\n### Authentication\n- `POST /api/v1/auth/register` - Register new user\n- `POST /api/v1/auth/login` - Login and get JWT token\n- `GET /api/v1/auth/profile` - Get user profile (authenticated)\n\n### Admin Configuration\n- `GET /api/v1/admin/configs` - List all configs (admin only)\n- `GET /api/v1/admin/configs/:key` - Get specific config (admin only)\n- `PUT /api/v1/admin/configs/:key` - Update/create config (admin only)\n\n### Categories\n- `GET /api/v1/categories` - List all categories (public)\n- `GET /api/v1/categories/:id` - Get category by ID (public)\n- `POST /api/v1/categories` - Create category (admin only)\n- `PUT /api/v1/categories/:id` - Update category (admin only)\n- `DELETE /api/v1/categories/:id` - Delete category (admin only)\n\n### Items\n- `GET /api/v1/items` - List items with filters (public)\n- `GET /api/v1/items/:id` - Get item details (public)\n- `POST /api/v1/items` - Create item listing (authenticated)\n- `PUT /api/v1/items/:id` - Update item (owner/admin)\n- `DELETE /api/v1/items/:id` - Delete item (owner/admin)\n- `PUT /api/v1/items/:id/status` - Update item status (admin only)\n\n### Cart\n- `GET /api/v1/cart` - Get user's cart (authenticated)\n- `POST /api/v1/cart` - Add item to cart (authenticated)\n- `PUT /api/v1/cart/:id` - Update cart item quantity (authenticated)\n- `DELETE /api/v1/cart/:id` - Remove item from cart (authenticated)\n- `DELETE /api/v1/cart` - Clear entire cart (authenticated)\n\n### Orders\n- `GET /api/v1/orders` - List user's orders (authenticated)\n- `GET /api/v1/orders/:id` - Get order details (authenticated)\n- `POST /api/v1/orders` - Create order from cart (authenticated)\n- `PUT /api/v1/orders/:id/status` - Update order status (admin only)\n\n### Negotiations\n- `GET /api/v1/negotiations` - List user's negotiations (authenticated)\n- `GET /api/v1/negotiations/:id` - Get negotiation details (authenticated)\n- `POST /api/v1/negotiations` - Create price offer (authenticated)\n- `PUT /api/v1/negotiations/:id/respond` - Accept/reject negotiation (seller only)\n\n### Notifications\n- `GET /api/v1/notifications` - List user's notifications (authenticated)\n- `PUT /api/v1/notifications/:id/read` - Mark notification as read (authenticated)\n- `PUT /api/v1/notifications/read-all` - Mark all as read (authenticated)\n\n### Transactions\n- `GET /api/v1/transactions` - List user's transactions (authenticated)\n- `POST /api/v1/transactions/withdraw` - Request withdrawal (authenticated)\n- `GET /api/v1/transactions/withdrawals` - List withdrawal requests (authenticated)\n\n## Environment Variables\n\n```bash\nNODE_ENV=development\nPORT=5000\nDATABASE_URL=postgresql://user:password@host:port/database\nJWT_SECRET=your-super-secret-jwt-key\nJWT_EXPIRES_IN=7d\nUPLOAD_DIR=./uploads\nADMIN_EMAIL=admin@sharewardrobe.com\nADMIN_PASSWORD=admin123\n```\n\n## Default Admin Credentials\n- Email: `admin@sharewardrobe.com`\n- Password: `admin123`\n- **Important**: Change these credentials in production!\n\n## Default Admin Configurations\n- `delivery_charge_per_order`: 100.00 TK\n- `safety_deposit_percentage`: 30%\n- `rental_period_days`: 7 days\n- `platform_fee_sale_percent`: 8%\n- `platform_fee_rental_percent`: 16%\n- `negotiation_hold_minutes`: 1440 minutes (24 hours)\n- `payment_timeout_minutes`: 1440 minutes (24 hours)\n\n## Scripts\n\n```bash\nnpm run dev          # Start development server with hot reload\nnpm run start        # Start production server\nnpm run build        # Compile TypeScript to JavaScript\nnpm run db:push      # Push schema changes to database\nnpm run db:seed      # Seed database with default configs and admin user\nnpm run db:studio    # Open Drizzle Studio (database GUI)\n```\n\n## Error Handling\n\nAll errors return a structured JSON response:\n```json\n{\n  \"success\": false,\n  \"error\": \"Error message\",\n  \"requestId\": \"uuid-request-id\"\n}\n```\n\nRequest IDs are included in:\n- All API responses\n- `X-Request-ID` response header\n- Server logs for tracing\n\n## Security Features\n\n- **JWT Authentication**: Secure token-based auth\n- **RBAC**: Role-based access control (user, seller, user_seller, admin)\n- **Rate Limiting**: 100 requests per 15 minutes per IP\n- **Helmet**: Security headers\n- **CORS**: Cross-origin resource sharing enabled\n- **Input Validation**: Zod schemas at controller layer\n- **Database Constraints**: Check constraints as last line of defense\n\n## Future Integrations Roadmap\n\n### Immediate Next Steps\n1. Implement remaining CRUD APIs (items, categories, cart, orders, negotiations, rentals)\n2. Add transaction management for order processing\n3. Implement inventory management with SELECT FOR UPDATE\n\n### Phase 2\n1. Switch to MinIO for file storage\n2. Integrate Redis + BullMQ for background jobs (cart expiry, rental reminders, payment timeouts)\n3. Add email/SMS notifications (Twilio, SendGrid)\n\n### Phase 3\n1. Integrate Bkash/Stripe for payments\n2. Integrate Pathao for delivery tracking\n3. Add real-time notifications with Socket.io\n4. Consider Keycloak for advanced auth\n\n## Development Guidelines\n\n### Adding New API Endpoints\n1. Create validation schema in `src/validations/`\n2. Create controller in `src/controllers/`\n3. Create route in `src/routes/`\n4. Add route to `src/routes/index.ts`\n\n### Database Changes\n1. Update schema in `src/db/schema.ts`\n2. Run `npm run db:push` to sync (or `npm run db:push --force` if needed)\n3. Update seed script if adding new default data\n\n### Switching Pluggable Services\n1. Implement the service interface\n2. Update the export in `src/services/[service]/index.ts`\n3. No other code changes required!\n\n## Project Structure\n\n```\nsrc/\n├── config/          # Environment configuration\n├── controllers/     # Request handlers\n├── db/              # Database schema and connection\n├── middleware/      # Express middleware (auth, validation, errors)\n├── routes/          # API routes\n├── scripts/         # Utility scripts (seed, etc.)\n├── services/        # Pluggable services (auth, storage, jobs, etc.)\n├── types/           # TypeScript type definitions\n├── utils/           # Utility functions and error classes\n├── validations/     # Zod validation schemas\n├── app.ts           # Express app configuration\n└── server.ts        # Server entry point\n```\n\n## Recent Changes\n- 2025-10-03: Initial backend setup with pluggable architecture\n- Database schema created with all tables, indexes, and constraints\n- Core authentication and admin APIs implemented\n- Health check endpoints added\n- Database seeded with default configurations\n- Implemented complete Category, Item, Cart, Order, Negotiation, Notification, and Transaction APIs\n- All core marketplace features are now functional\n- Integrated pluggable payment and delivery services\n- Added comprehensive validation and error handling across all endpoints\n- **2025-10-03: Successfully imported and configured for Replit environment**\n  - Installed all npm dependencies\n  - Created PostgreSQL database (Neon-backed)\n  - Pushed database schema and seeded initial data\n  - Configured environment variables\n  - Server running on port 5000\n  - Deployment configured for autoscale (stateless API)\n\n## User Preferences\n- Priority: Pluggable architecture for future integrations\n- File storage: Local directory (scope for MinIO)\n- Background jobs: In-memory logging (scope for Redis + BullMQ)\n- Auth: JWT (scope for Keycloak)\n- Notifications: In-app only (scope for email/SMS/Socket.io)\n- Payment: Mock service (scope for Bkash/Stripe)\n- Delivery: Mock service (scope for Pathao)\n","size_bytes":11682},"src/app.ts":{"content":"import express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport { requestIdMiddleware } from './middleware/requestId';\nimport { errorHandler, notFoundHandler } from './middleware/errorHandler';\nimport routes from './routes';\nimport { env } from './config/env';\n\nconst app = express();\n\napp.set('trust proxy', 1);\n\napp.use(helmet());\napp.use(cors());\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\napp.use(requestIdMiddleware);\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use(limiter);\n\napp.use('/api/v1', routes);\n\napp.use('/uploads', express.static(env.UPLOAD_DIR));\n\napp.use(notFoundHandler);\napp.use(errorHandler);\n\nexport default app;\n","size_bytes":854},"src/server.ts":{"content":"import app from './app';\nimport { env, validateEnv } from './config/env';\n\nasync function startServer() {\n  try {\n    validateEnv();\n\n    const PORT = env.PORT;\n    \n    app.listen(PORT, '0.0.0.0', () => {\n      console.log(`🚀 Server running on port ${PORT}`);\n      console.log(`📦 Environment: ${env.NODE_ENV}`);\n      console.log(`🏥 Health check: http://localhost:${PORT}/api/v1/health`);\n    });\n  } catch (error) {\n    console.error('Failed to start server:', error);\n    process.exit(1);\n  }\n}\n\nstartServer();\n","size_bytes":524},"src/config/env.ts":{"content":"import dotenv from 'dotenv';\n\ndotenv.config();\n\nexport const env = {\n  NODE_ENV: process.env.NODE_ENV || 'development',\n  PORT: parseInt(process.env.PORT || '5000', 10),\n  DATABASE_URL: process.env.DATABASE_URL || '',\n  JWT_SECRET: process.env.JWT_SECRET || 'change-this-secret',\n  JWT_EXPIRES_IN: process.env.JWT_EXPIRES_IN || '7d',\n  UPLOAD_DIR: process.env.UPLOAD_DIR || './uploads',\n  ADMIN_EMAIL: process.env.ADMIN_EMAIL || 'admin@sharewardrobe.com',\n  ADMIN_PASSWORD: process.env.ADMIN_PASSWORD || 'admin123',\n};\n\nexport function validateEnv() {\n  const required = ['DATABASE_URL', 'JWT_SECRET'];\n  const missing = required.filter((key) => !process.env[key]);\n\n  if (missing.length > 0) {\n    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);\n  }\n}\n","size_bytes":787},"src/controllers/admin.controller.ts":{"content":"import { Response, NextFunction } from 'express';\nimport { db } from '../db';\nimport { adminConfigs } from '../db/schema';\nimport { eq } from 'drizzle-orm';\nimport { AuthRequest } from '../types';\nimport { NotFoundError } from '../utils/error';\n\nexport class AdminController {\n  async getConfig(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { key } = req.params;\n\n      const [config] = await db\n        .select()\n        .from(adminConfigs)\n        .where(eq(adminConfigs.key, key))\n        .limit(1);\n\n      if (!config) {\n        throw new NotFoundError(`Config key '${key}' not found`);\n      }\n\n      res.json({\n        success: true,\n        data: config,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async getAllConfigs(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const configs = await db.select().from(adminConfigs);\n\n      res.json({\n        success: true,\n        data: configs,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async updateConfig(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { key } = req.params;\n      const { value, description } = req.body;\n\n      const [updated] = await db\n        .update(adminConfigs)\n        .set({ value, description, updatedAt: new Date() })\n        .where(eq(adminConfigs.key, key))\n        .returning();\n\n      if (!updated) {\n        const [created] = await db\n          .insert(adminConfigs)\n          .values({ key, value, description })\n          .returning();\n\n        return res.status(201).json({\n          success: true,\n          data: created,\n          message: 'Config created',\n          requestId: req.requestId,\n        });\n      }\n\n      res.json({\n        success: true,\n        data: updated,\n        message: 'Config updated',\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n","size_bytes":1990},"src/controllers/auth.controller.ts":{"content":"import { Response, NextFunction } from 'express';\nimport { db } from '../db';\nimport { users } from '../db/schema';\nimport { eq, and, isNull } from 'drizzle-orm';\nimport { authService } from '../services/auth';\nimport { storageService } from '../services/storage';\nimport { AuthRequest } from '../types';\nimport { ConflictError, UnauthorizedError, ValidationError } from '../utils/error';\n\nexport class AuthController {\n  async register(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { name, email, password, address, phone } = req.body;\n\n      const [existingUser] = await db\n        .select()\n        .from(users)\n        .where(and(eq(users.email, email), isNull(users.deletedAt)))\n        .limit(1);\n\n      if (existingUser) {\n        throw new ConflictError('Email already registered');\n      }\n\n      const passwordHash = await authService.hashPassword(password);\n\n      const [user] = await db\n        .insert(users)\n        .values({\n          name,\n          email,\n          passwordHash,\n          address: address || null,\n          phone: phone || null,\n          role: 'user',\n          status: 'active',\n        })\n        .returning({\n          id: users.id,\n          name: users.name,\n          email: users.email,\n          role: users.role,\n        });\n\n      const token = authService.generateToken({\n        userId: user.id,\n        email: user.email,\n        role: user.role,\n      });\n\n      res.status(201).json({\n        success: true,\n        data: { user, token },\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async login(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { email, password } = req.body;\n\n      const [user] = await db\n        .select()\n        .from(users)\n        .where(and(eq(users.email, email), isNull(users.deletedAt)))\n        .limit(1);\n\n      if (!user) {\n        throw new UnauthorizedError('Invalid email or password');\n      }\n\n      if (user.status === 'suspended') {\n        throw new UnauthorizedError('Your account has been suspended');\n      }\n\n      if (user.status !== 'active') {\n        throw new UnauthorizedError('Your account is not active');\n      }\n\n      const isPasswordValid = await authService.comparePassword(password, user.passwordHash);\n\n      if (!isPasswordValid) {\n        throw new UnauthorizedError('Invalid email or password');\n      }\n\n      const token = authService.generateToken({\n        userId: user.id,\n        email: user.email,\n        role: user.role,\n      });\n\n      res.json({\n        success: true,\n        data: {\n          user: {\n            id: user.id,\n            name: user.name,\n            email: user.email,\n            role: user.role,\n            balance: user.balance,\n          },\n          token,\n        },\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async getProfile(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const [user] = await db\n        .select({\n          id: users.id,\n          name: users.name,\n          email: users.email,\n          role: users.role,\n          status: users.status,\n          address: users.address,\n          phone: users.phone,\n          balance: users.balance,\n          verificationStatus: users.verificationStatus,\n          createdAt: users.createdAt,\n        })\n        .from(users)\n        .where(eq(users.id, req.user!.id))\n        .limit(1);\n\n      res.json({\n        success: true,\n        data: user,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n","size_bytes":3645},"src/controllers/cart.controller.ts":{"content":"import { Response, NextFunction } from 'express';\nimport { db } from '../db';\nimport { cartItems, items } from '../db/schema';\nimport { eq, and, isNull } from 'drizzle-orm';\nimport { AuthRequest } from '../types';\nimport { NotFoundError, ValidationError, ConflictError } from '../utils/error';\n\nexport class CartController {\n  async addItem(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { itemId, quantity, type } = req.body;\n\n      const [item] = await db\n        .select()\n        .from(items)\n        .where(and(eq(items.id, itemId), isNull(items.deletedAt)))\n        .limit(1);\n\n      if (!item) {\n        throw new NotFoundError('Item not found');\n      }\n\n      if (item.status !== 'available') {\n        throw new ValidationError('Item is not available');\n      }\n\n      if (type === 'buy' && item.availability === 'rent_only') {\n        throw new ValidationError('This item is only available for rent');\n      }\n\n      if (type === 'rent' && item.availability === 'sell_only') {\n        throw new ValidationError('This item is only available for sale');\n      }\n\n      const [existing] = await db\n        .select()\n        .from(cartItems)\n        .where(\n          and(\n            eq(cartItems.userId, req.user!.id),\n            eq(cartItems.itemId, itemId),\n            eq(cartItems.type, type)\n          )\n        )\n        .limit(1);\n\n      if (existing) {\n        const [updated] = await db\n          .update(cartItems)\n          .set({ quantity: existing.quantity + quantity })\n          .where(eq(cartItems.id, existing.id))\n          .returning();\n\n        return res.json({\n          success: true,\n          data: updated,\n          message: 'Cart item quantity updated',\n          requestId: req.requestId,\n        });\n      }\n\n      const [cartItem] = await db\n        .insert(cartItems)\n        .values({\n          userId: req.user!.id,\n          itemId,\n          quantity,\n          type,\n        })\n        .returning();\n\n      res.status(201).json({\n        success: true,\n        data: cartItem,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async getCart(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const cart = await db\n        .select({\n          id: cartItems.id,\n          quantity: cartItems.quantity,\n          type: cartItems.type,\n          negotiatedPrice: cartItems.negotiatedPrice,\n          negotiatedExpiresAt: cartItems.negotiatedExpiresAt,\n          addedAt: cartItems.addedAt,\n          item: {\n            id: items.id,\n            name: items.description,\n            sellPrice: items.sellPrice,\n            rentPrice: items.rentPrice,\n            images: items.images,\n            status: items.status,\n            availability: items.availability,\n          },\n        })\n        .from(cartItems)\n        .leftJoin(items, eq(cartItems.itemId, items.id))\n        .where(eq(cartItems.userId, req.user!.id));\n\n      res.json({\n        success: true,\n        data: cart,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async updateItem(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n      const { quantity } = req.body;\n\n      const [updated] = await db\n        .update(cartItems)\n        .set({ quantity })\n        .where(and(eq(cartItems.id, parseInt(id)), eq(cartItems.userId, req.user!.id)))\n        .returning();\n\n      if (!updated) {\n        throw new NotFoundError('Cart item not found');\n      }\n\n      res.json({\n        success: true,\n        data: updated,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async removeItem(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n\n      const [deleted] = await db\n        .delete(cartItems)\n        .where(and(eq(cartItems.id, parseInt(id)), eq(cartItems.userId, req.user!.id)))\n        .returning();\n\n      if (!deleted) {\n        throw new NotFoundError('Cart item not found');\n      }\n\n      res.json({\n        success: true,\n        message: 'Item removed from cart',\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async clearCart(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      await db.delete(cartItems).where(eq(cartItems.userId, req.user!.id));\n\n      res.json({\n        success: true,\n        message: 'Cart cleared successfully',\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n","size_bytes":4618},"src/controllers/category.controller.ts":{"content":"import { Response, NextFunction } from 'express';\nimport { db } from '../db';\nimport { categories } from '../db/schema';\nimport { eq, and, isNull, ilike } from 'drizzle-orm';\nimport { AuthRequest } from '../types';\nimport { NotFoundError, ConflictError } from '../utils/error';\n\nexport class CategoryController {\n  async create(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { name, slug, description } = req.body;\n\n      const [existing] = await db\n        .select()\n        .from(categories)\n        .where(and(eq(categories.name, name), isNull(categories.deletedAt)))\n        .limit(1);\n\n      if (existing) {\n        throw new ConflictError('Category with this name already exists');\n      }\n\n      const [category] = await db\n        .insert(categories)\n        .values({\n          name,\n          slug: slug || name.toLowerCase().replace(/\\s+/g, '-'),\n          description,\n        })\n        .returning();\n\n      res.status(201).json({\n        success: true,\n        data: category,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async list(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { search } = req.query;\n      const page = parseInt(req.query.page as string) || 1;\n      const limit = parseInt(req.query.limit as string) || 20;\n      const offset = (page - 1) * limit;\n\n      let conditions = [isNull(categories.deletedAt)];\n\n      if (search) {\n        conditions.push(ilike(categories.name, `%${search}%`));\n      }\n\n      const items = await db\n        .select()\n        .from(categories)\n        .where(and(...conditions))\n        .limit(limit)\n        .offset(offset);\n\n      res.json({\n        success: true,\n        data: items,\n        pagination: {\n          page,\n          limit,\n          total: items.length,\n        },\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async getById(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n\n      const [category] = await db\n        .select()\n        .from(categories)\n        .where(and(eq(categories.id, parseInt(id)), isNull(categories.deletedAt)))\n        .limit(1);\n\n      if (!category) {\n        throw new NotFoundError('Category not found');\n      }\n\n      res.json({\n        success: true,\n        data: category,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async update(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n      const { name, slug, description } = req.body;\n\n      const [updated] = await db\n        .update(categories)\n        .set({\n          ...(name && { name }),\n          ...(slug && { slug }),\n          ...(description !== undefined && { description }),\n          updatedAt: new Date(),\n        })\n        .where(and(eq(categories.id, parseInt(id)), isNull(categories.deletedAt)))\n        .returning();\n\n      if (!updated) {\n        throw new NotFoundError('Category not found');\n      }\n\n      res.json({\n        success: true,\n        data: updated,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async delete(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n\n      const [deleted] = await db\n        .update(categories)\n        .set({ deletedAt: new Date() })\n        .where(and(eq(categories.id, parseInt(id)), isNull(categories.deletedAt)))\n        .returning();\n\n      if (!deleted) {\n        throw new NotFoundError('Category not found');\n      }\n\n      res.json({\n        success: true,\n        message: 'Category deleted successfully',\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n","size_bytes":3856},"src/controllers/item.controller.ts":{"content":"import { Response, NextFunction } from 'express';\nimport { db } from '../db';\nimport { items, categories, users } from '../db/schema';\nimport { eq, and, isNull, sql, gte, lte } from 'drizzle-orm';\nimport { AuthRequest } from '../types';\nimport { NotFoundError, ValidationError, ForbiddenError } from '../utils/error';\n\nexport class ItemController {\n  async create(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const {\n        categoryId,\n        type,\n        color,\n        size,\n        wearingTime,\n        purchasePrice,\n        description,\n        sellPrice,\n        rentPrice,\n        availability,\n        quantity,\n        images,\n        video,\n      } = req.body;\n\n      if (availability === 'sell_only' && !sellPrice) {\n        throw new ValidationError('Sell price is required for sell_only items');\n      }\n      if (availability === 'rent_only' && !rentPrice) {\n        throw new ValidationError('Rent price is required for rent_only items');\n      }\n      if (availability === 'both' && (!sellPrice || !rentPrice)) {\n        throw new ValidationError('Both sell and rent prices are required for both availability');\n      }\n\n      const [item] = await db\n        .insert(items)\n        .values({\n          sellerId: req.user!.id,\n          categoryId,\n          type,\n          color,\n          size,\n          wearingTime,\n          purchasePrice: purchasePrice.toString(),\n          description,\n          sellPrice: sellPrice ? sellPrice.toString() : null,\n          rentPrice: rentPrice ? rentPrice.toString() : null,\n          availability,\n          quantity,\n          images,\n          video,\n          status: 'pending_approval',\n        })\n        .returning();\n\n      res.status(201).json({\n        success: true,\n        data: item,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async list(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const {\n        categoryId,\n        type,\n        color,\n        size,\n        minPrice,\n        maxPrice,\n        wearingTime,\n        availability,\n        status,\n      } = req.query;\n\n      const page = parseInt(req.query.page as string) || 1;\n      const limit = parseInt(req.query.limit as string) || 20;\n      const offset = (page - 1) * limit;\n\n      let conditions = [isNull(items.deletedAt)];\n\n      if (categoryId) {\n        conditions.push(eq(items.categoryId, parseInt(categoryId as string)));\n      }\n      if (type) {\n        conditions.push(eq(items.type, type as string));\n      }\n      if (color) {\n        conditions.push(eq(items.color, color as string));\n      }\n      if (size) {\n        conditions.push(eq(items.size, size as string));\n      }\n      if (wearingTime) {\n        conditions.push(eq(items.wearingTime, wearingTime as string));\n      }\n      if (availability) {\n        conditions.push(eq(items.availability, availability as any));\n      }\n      if (status) {\n        conditions.push(eq(items.status, status as any));\n      }\n      if (minPrice) {\n        conditions.push(gte(items.sellPrice, minPrice as string));\n      }\n      if (maxPrice) {\n        conditions.push(lte(items.sellPrice, maxPrice as string));\n      }\n\n      const itemsList = await db\n        .select({\n          id: items.id,\n          sellerId: items.sellerId,\n          categoryId: items.categoryId,\n          type: items.type,\n          color: items.color,\n          size: items.size,\n          wearingTime: items.wearingTime,\n          purchasePrice: items.purchasePrice,\n          description: items.description,\n          sellPrice: items.sellPrice,\n          rentPrice: items.rentPrice,\n          availability: items.availability,\n          quantity: items.quantity,\n          images: items.images,\n          video: items.video,\n          status: items.status,\n          createdAt: items.createdAt,\n          seller: {\n            id: users.id,\n            name: users.name,\n          },\n          category: {\n            id: categories.id,\n            name: categories.name,\n          },\n        })\n        .from(items)\n        .leftJoin(users, eq(items.sellerId, users.id))\n        .leftJoin(categories, eq(items.categoryId, categories.id))\n        .where(and(...conditions))\n        .limit(limit)\n        .offset(offset);\n\n      res.json({\n        success: true,\n        data: itemsList,\n        pagination: {\n          page,\n          limit,\n        },\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async getById(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n\n      const [item] = await db\n        .select({\n          id: items.id,\n          sellerId: items.sellerId,\n          categoryId: items.categoryId,\n          type: items.type,\n          color: items.color,\n          size: items.size,\n          wearingTime: items.wearingTime,\n          purchasePrice: items.purchasePrice,\n          description: items.description,\n          sellPrice: items.sellPrice,\n          rentPrice: items.rentPrice,\n          availability: items.availability,\n          quantity: items.quantity,\n          images: items.images,\n          video: items.video,\n          status: items.status,\n          createdAt: items.createdAt,\n          seller: {\n            id: users.id,\n            name: users.name,\n          },\n          category: {\n            id: categories.id,\n            name: categories.name,\n          },\n        })\n        .from(items)\n        .leftJoin(users, eq(items.sellerId, users.id))\n        .leftJoin(categories, eq(items.categoryId, categories.id))\n        .where(and(eq(items.id, parseInt(id)), isNull(items.deletedAt)))\n        .limit(1);\n\n      if (!item) {\n        throw new NotFoundError('Item not found');\n      }\n\n      res.json({\n        success: true,\n        data: item,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async update(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n\n      const [item] = await db\n        .select()\n        .from(items)\n        .where(and(eq(items.id, parseInt(id)), isNull(items.deletedAt)))\n        .limit(1);\n\n      if (!item) {\n        throw new NotFoundError('Item not found');\n      }\n\n      if (item.sellerId !== req.user!.id && req.user!.role !== 'admin') {\n        throw new ForbiddenError('You can only update your own items');\n      }\n\n      const updateData: any = { updatedAt: new Date() };\n\n      const fields = [\n        'type',\n        'color',\n        'size',\n        'wearingTime',\n        'purchasePrice',\n        'description',\n        'sellPrice',\n        'rentPrice',\n        'availability',\n        'quantity',\n        'images',\n        'video',\n      ];\n\n      fields.forEach((field) => {\n        if (req.body[field] !== undefined) {\n          if (['purchasePrice', 'sellPrice', 'rentPrice'].includes(field) && req.body[field] !== null) {\n            updateData[field] = req.body[field].toString();\n          } else {\n            updateData[field] = req.body[field];\n          }\n        }\n      });\n\n      const [updated] = await db\n        .update(items)\n        .set(updateData)\n        .where(eq(items.id, parseInt(id)))\n        .returning();\n\n      res.json({\n        success: true,\n        data: updated,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async delete(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n\n      const [item] = await db\n        .select()\n        .from(items)\n        .where(and(eq(items.id, parseInt(id)), isNull(items.deletedAt)))\n        .limit(1);\n\n      if (!item) {\n        throw new NotFoundError('Item not found');\n      }\n\n      if (item.sellerId !== req.user!.id && req.user!.role !== 'admin') {\n        throw new ForbiddenError('You can only delete your own items');\n      }\n\n      await db\n        .update(items)\n        .set({ deletedAt: new Date() })\n        .where(eq(items.id, parseInt(id)));\n\n      res.json({\n        success: true,\n        message: 'Item deleted successfully',\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async updateStatus(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n      const { status } = req.body;\n\n      const [updated] = await db\n        .update(items)\n        .set({ status, updatedAt: new Date() })\n        .where(and(eq(items.id, parseInt(id)), isNull(items.deletedAt)))\n        .returning();\n\n      if (!updated) {\n        throw new NotFoundError('Item not found');\n      }\n\n      res.json({\n        success: true,\n        data: updated,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n","size_bytes":8875},"src/controllers/negotiation.controller.ts":{"content":"import { Response, NextFunction } from 'express';\nimport { db } from '../db';\nimport { negotiations, items, cartItems, adminConfigs } from '../db/schema';\nimport { eq, and, isNull } from 'drizzle-orm';\nimport { AuthRequest } from '../types';\nimport { NotFoundError, ForbiddenError, ValidationError } from '../utils/error';\n\nexport class NegotiationController {\n  async create(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { itemId, offerPrice, expiresAt } = req.body;\n\n      const [item] = await db\n        .select()\n        .from(items)\n        .where(and(eq(items.id, itemId), isNull(items.deletedAt)))\n        .limit(1);\n\n      if (!item) {\n        throw new NotFoundError('Item not found');\n      }\n\n      if (item.sellerId === req.user!.id) {\n        throw new ValidationError('You cannot negotiate on your own items');\n      }\n\n      const [negotiation] = await db\n        .insert(negotiations)\n        .values({\n          itemId,\n          buyerId: req.user!.id,\n          offerPrice: offerPrice.toString(),\n          expiresAt: expiresAt ? new Date(expiresAt) : null,\n        })\n        .returning();\n\n      res.status(201).json({\n        success: true,\n        data: negotiation,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async list(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const page = parseInt(req.query.page as string) || 1;\n      const limit = parseInt(req.query.limit as string) || 20;\n      const offset = (page - 1) * limit;\n\n      const negotiationsList = await db\n        .select({\n          id: negotiations.id,\n          offerPrice: negotiations.offerPrice,\n          status: negotiations.status,\n          expiresAt: negotiations.expiresAt,\n          createdAt: negotiations.createdAt,\n          item: {\n            id: items.id,\n            description: items.description,\n            sellPrice: items.sellPrice,\n            rentPrice: items.rentPrice,\n          },\n        })\n        .from(negotiations)\n        .leftJoin(items, eq(negotiations.itemId, items.id))\n        .where(\n          and(\n            eq(negotiations.buyerId, req.user!.id),\n            isNull(negotiations.deletedAt)\n          )\n        )\n        .limit(limit)\n        .offset(offset);\n\n      res.json({\n        success: true,\n        data: negotiationsList,\n        pagination: { page, limit },\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async getById(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n\n      const [negotiation] = await db\n        .select()\n        .from(negotiations)\n        .where(and(eq(negotiations.id, parseInt(id)), isNull(negotiations.deletedAt)))\n        .limit(1);\n\n      if (!negotiation) {\n        throw new NotFoundError('Negotiation not found');\n      }\n\n      res.json({\n        success: true,\n        data: negotiation,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async respond(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n      const { status } = req.body;\n\n      const [negotiation] = await db\n        .select()\n        .from(negotiations)\n        .where(and(eq(negotiations.id, parseInt(id)), isNull(negotiations.deletedAt)))\n        .limit(1);\n\n      if (!negotiation) {\n        throw new NotFoundError('Negotiation not found');\n      }\n\n      const [item] = await db\n        .select()\n        .from(items)\n        .where(eq(items.id, negotiation.itemId))\n        .limit(1);\n\n      if (!item || item.sellerId !== req.user!.id) {\n        throw new ForbiddenError('You can only respond to negotiations on your own items');\n      }\n\n      const [updated] = await db\n        .update(negotiations)\n        .set({ status, updatedAt: new Date() })\n        .where(eq(negotiations.id, parseInt(id)))\n        .returning();\n\n      if (status === 'accepted') {\n        const [config] = await db\n          .select()\n          .from(adminConfigs)\n          .where(eq(adminConfigs.key, 'negotiation_hold_minutes'))\n          .limit(1);\n\n        const holdMinutes = config ? parseInt(config.value) : 1440;\n        const expiresAt = new Date(Date.now() + holdMinutes * 60 * 1000);\n\n        await db\n          .insert(cartItems)\n          .values({\n            userId: negotiation.buyerId,\n            itemId: negotiation.itemId,\n            quantity: 1,\n            type: 'buy',\n            negotiatedPrice: negotiation.offerPrice,\n            negotiatedExpiresAt: expiresAt,\n            negotiationId: negotiation.id,\n          })\n          .onConflictDoUpdate({\n            target: [cartItems.userId, cartItems.itemId, cartItems.type],\n            set: {\n              negotiatedPrice: negotiation.offerPrice,\n              negotiatedExpiresAt: expiresAt,\n              negotiationId: negotiation.id,\n            },\n          });\n      }\n\n      res.json({\n        success: true,\n        data: updated,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n","size_bytes":5145},"src/controllers/notification.controller.ts":{"content":"import { Response, NextFunction } from 'express';\nimport { db } from '../db';\nimport { notifications } from '../db/schema';\nimport { eq, and, isNull } from 'drizzle-orm';\nimport { AuthRequest } from '../types';\n\nexport class NotificationController {\n  async list(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const page = parseInt(req.query.page as string) || 1;\n      const limit = parseInt(req.query.limit as string) || 20;\n      const offset = (page - 1) * limit;\n\n      const notificationsList = await db\n        .select()\n        .from(notifications)\n        .where(and(eq(notifications.userId, req.user!.id), isNull(notifications.deletedAt)))\n        .orderBy(notifications.createdAt)\n        .limit(limit)\n        .offset(offset);\n\n      res.json({\n        success: true,\n        data: notificationsList,\n        pagination: { page, limit },\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async markAsRead(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n\n      const [updated] = await db\n        .update(notifications)\n        .set({ isRead: true })\n        .where(and(eq(notifications.id, parseInt(id)), eq(notifications.userId, req.user!.id)))\n        .returning();\n\n      res.json({\n        success: true,\n        data: updated,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async markAllAsRead(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      await db\n        .update(notifications)\n        .set({ isRead: true })\n        .where(eq(notifications.userId, req.user!.id));\n\n      res.json({\n        success: true,\n        message: 'All notifications marked as read',\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n","size_bytes":1872},"src/controllers/order.controller.ts":{"content":"import { Response, NextFunction } from 'express';\nimport { db } from '../db';\nimport {\n  orders,\n  orderItems,\n  cartItems,\n  items,\n  adminConfigs,\n  transactions,\n  users,\n} from '../db/schema';\nimport { eq, and, isNull, sql } from 'drizzle-orm';\nimport { AuthRequest } from '../types';\nimport { NotFoundError, ValidationError } from '../utils/error';\nimport { paymentService } from '../services/payment';\nimport { deliveryService } from '../services/delivery';\n\nexport class OrderController {\n  async create(req: AuthRequest, res: Response, next: NextFunction) {\n    const dbClient = db as any;\n\n    try {\n      const { paymentMethod, deliveryAddress } = req.body;\n\n      const result = await dbClient.transaction(async (tx: any) => {\n        const cart = await tx\n          .select()\n          .from(cartItems)\n          .where(eq(cartItems.userId, req.user!.id));\n\n        if (cart.length === 0) {\n          throw new ValidationError('Cart is empty');\n        }\n\n        const [deliveryChargeConfig] = await tx\n          .select()\n          .from(adminConfigs)\n          .where(eq(adminConfigs.key, 'delivery_charge_per_order'))\n          .limit(1);\n\n        const deliveryCharge = deliveryChargeConfig\n          ? parseFloat(deliveryChargeConfig.value)\n          : 100.0;\n\n        let totalAmount = deliveryCharge;\n        let safetyDeposit = 0;\n\n        const itemsData = [];\n\n        for (const cartItem of cart) {\n          const [item] = await tx\n            .select()\n            .from(items)\n            .where(and(eq(items.id, cartItem.itemId), isNull(items.deletedAt)))\n            .limit(1)\n            .for('update');\n\n          if (!item) {\n            throw new NotFoundError(`Item ${cartItem.itemId} not found`);\n          }\n\n          if (item.quantity < cartItem.quantity) {\n            throw new ValidationError(\n              `Insufficient quantity for item ${item.id}. Available: ${item.quantity}, Requested: ${cartItem.quantity}`\n            );\n          }\n\n          const price =\n            cartItem.negotiatedPrice ||\n            (cartItem.type === 'buy' ? item.sellPrice : item.rentPrice);\n\n          if (!price) {\n            throw new ValidationError(`Price not available for item ${item.id}`);\n          }\n\n          const itemTotal = parseFloat(price) * cartItem.quantity;\n          totalAmount += itemTotal;\n\n          if (cartItem.type === 'rent') {\n            const [depositConfig] = await tx\n              .select()\n              .from(adminConfigs)\n              .where(eq(adminConfigs.key, 'safety_deposit_percentage'))\n              .limit(1);\n\n            const depositPercent = depositConfig\n              ? parseFloat(depositConfig.value)\n              : 30;\n\n            safetyDeposit += (itemTotal * depositPercent) / 100;\n          }\n\n          itemsData.push({\n            item,\n            cartItem,\n            price,\n          });\n        }\n\n        const [timeoutConfig] = await tx\n          .select()\n          .from(adminConfigs)\n          .where(eq(adminConfigs.key, 'payment_timeout_minutes'))\n          .limit(1);\n\n        const timeoutMinutes = timeoutConfig ? parseInt(timeoutConfig.value) : 1440;\n        const paymentDueAt = new Date(Date.now() + timeoutMinutes * 60 * 1000);\n\n        const [order] = await tx\n          .insert(orders)\n          .values({\n            buyerId: req.user!.id,\n            totalAmount: totalAmount.toString(),\n            deliveryCharge: deliveryCharge.toString(),\n            safetyDeposit: safetyDeposit.toString(),\n            paymentMethod,\n            status: 'pending',\n            paymentDueAt,\n            deliveryChargePaid: false,\n          })\n          .returning();\n\n        for (const { item, cartItem, price } of itemsData) {\n          await tx.insert(orderItems).values({\n            orderId: order.id,\n            itemId: item.id,\n            quantity: cartItem.quantity,\n            price,\n            type: cartItem.type,\n          });\n\n          await tx\n            .update(items)\n            .set({\n              quantity: item.quantity - cartItem.quantity,\n            })\n            .where(eq(items.id, item.id));\n        }\n\n        await tx.delete(cartItems).where(eq(cartItems.userId, req.user!.id));\n\n        return { order, totalAmount };\n      });\n\n      if (paymentMethod === 'online') {\n        try {\n          const paymentResult = await paymentService.createPayment({\n            orderId: result.order.id,\n            amount: result.totalAmount,\n            description: `Order #${result.order.id}`,\n          });\n\n          if (paymentResult.success) {\n            await db\n              .update(orders)\n              .set({\n                status: 'paid',\n                deliveryChargePaid: true,\n                updatedAt: new Date(),\n              })\n              .where(eq(orders.id, result.order.id));\n\n            result.order.status = 'paid';\n            result.order.deliveryChargePaid = true;\n          }\n        } catch (paymentError) {\n          console.error('Payment service error:', paymentError);\n        }\n      } else {\n        await db\n          .update(orders)\n          .set({\n            deliveryChargePaid: true,\n            updatedAt: new Date(),\n          })\n          .where(eq(orders.id, result.order.id));\n      }\n\n      res.status(201).json({\n        success: true,\n        data: result.order,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async list(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const page = parseInt(req.query.page as string) || 1;\n      const limit = parseInt(req.query.limit as string) || 20;\n      const offset = (page - 1) * limit;\n\n      const ordersList = await db\n        .select()\n        .from(orders)\n        .where(and(eq(orders.buyerId, req.user!.id), isNull(orders.deletedAt)))\n        .limit(limit)\n        .offset(offset);\n\n      res.json({\n        success: true,\n        data: ordersList,\n        pagination: { page, limit },\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async getById(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n\n      const [order] = await db\n        .select()\n        .from(orders)\n        .where(and(eq(orders.id, parseInt(id)), isNull(orders.deletedAt)))\n        .limit(1);\n\n      if (!order) {\n        throw new NotFoundError('Order not found');\n      }\n\n      const items = await db\n        .select()\n        .from(orderItems)\n        .where(eq(orderItems.orderId, order.id));\n\n      res.json({\n        success: true,\n        data: { ...order, items },\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async updateStatus(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n      const { status } = req.body;\n\n      const [updated] = await db\n        .update(orders)\n        .set({ status, updatedAt: new Date() })\n        .where(and(eq(orders.id, parseInt(id)), isNull(orders.deletedAt)))\n        .returning();\n\n      if (!updated) {\n        throw new NotFoundError('Order not found');\n      }\n\n      res.json({\n        success: true,\n        data: updated,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n","size_bytes":7347},"src/controllers/transaction.controller.ts":{"content":"import { Response, NextFunction } from 'express';\nimport { db } from '../db';\nimport { transactions, withdrawalRequests, users } from '../db/schema';\nimport { eq, and, isNull, sql } from 'drizzle-orm';\nimport { AuthRequest } from '../types';\nimport { NotFoundError, ValidationError } from '../utils/error';\n\nexport class TransactionController {\n  async list(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const page = parseInt(req.query.page as string) || 1;\n      const limit = parseInt(req.query.limit as string) || 20;\n      const offset = (page - 1) * limit;\n\n      const transactionsList = await db\n        .select()\n        .from(transactions)\n        .where(and(eq(transactions.userId, req.user!.id), isNull(transactions.deletedAt)))\n        .orderBy(transactions.createdAt)\n        .limit(limit)\n        .offset(offset);\n\n      res.json({\n        success: true,\n        data: transactionsList,\n        pagination: { page, limit },\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async requestWithdrawal(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const { amount } = req.body;\n\n      const [user] = await db\n        .select()\n        .from(users)\n        .where(eq(users.id, req.user!.id))\n        .limit(1);\n\n      if (!user) {\n        throw new NotFoundError('User not found');\n      }\n\n      const balance = parseFloat(user.balance);\n      if (balance < amount) {\n        throw new ValidationError('Insufficient balance');\n      }\n\n      const [withdrawal] = await db\n        .insert(withdrawalRequests)\n        .values({\n          userId: req.user!.id,\n          amount: amount.toString(),\n        })\n        .returning();\n\n      await db\n        .update(users)\n        .set({\n          balance: sql`${users.balance} - ${amount}`,\n        })\n        .where(eq(users.id, req.user!.id));\n\n      await db.insert(transactions).values({\n        userId: req.user!.id,\n        amount: `-${amount}`,\n        type: 'withdrawal',\n        status: 'pending',\n        description: `Withdrawal request #${withdrawal.id}`,\n      });\n\n      res.status(201).json({\n        success: true,\n        data: withdrawal,\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async getWithdrawals(req: AuthRequest, res: Response, next: NextFunction) {\n    try {\n      const page = parseInt(req.query.page as string) || 1;\n      const limit = parseInt(req.query.limit as string) || 20;\n      const offset = (page - 1) * limit;\n\n      const withdrawalsList = await db\n        .select()\n        .from(withdrawalRequests)\n        .where(and(eq(withdrawalRequests.userId, req.user!.id), isNull(withdrawalRequests.deletedAt)))\n        .orderBy(withdrawalRequests.createdAt)\n        .limit(limit)\n        .offset(offset);\n\n      res.json({\n        success: true,\n        data: withdrawalsList,\n        pagination: { page, limit },\n        requestId: req.requestId,\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n","size_bytes":3052},"src/db/index.ts":{"content":"import { drizzle } from 'drizzle-orm/postgres-js';\nimport postgres from 'postgres';\nimport * as schema from './schema';\n\nconst connectionString = process.env.DATABASE_URL!;\n\nconst client = postgres(connectionString, { prepare: false });\n\nexport const db = drizzle(client, { schema });\n","size_bytes":285},"src/db/schema.ts":{"content":"import { pgTable, serial, text, decimal, integer, timestamp, boolean, pgEnum, jsonb, uniqueIndex, index, check } from 'drizzle-orm/pg-core';\nimport { relations, sql } from 'drizzle-orm';\n\nexport const roleEnum = pgEnum('role', ['user', 'seller', 'user_seller', 'admin']);\nexport const userStatusEnum = pgEnum('user_status', ['active', 'inactive', 'deleted', 'suspended']);\nexport const itemAvailabilityEnum = pgEnum('item_availability', ['sell_only', 'rent_only', 'both']);\nexport const itemStatusEnum = pgEnum('item_status', [\n  'pending_approval',\n  'available',\n  'in_warehouse',\n  'rented',\n  'sold',\n  'returned_pending',\n  'damaged',\n  'rejected'\n]);\nexport const orderTypeEnum = pgEnum('order_type', ['buy', 'rent']);\nexport const orderStatusEnum = pgEnum('order_status', [\n  'pending',\n  'paid',\n  'shipped',\n  'delivered',\n  'returned',\n  'partially_returned',\n  'cancelled',\n  'refunded'\n]);\nexport const orderItemStatusEnum = pgEnum('order_item_status', [\n  'pending',\n  'shipped',\n  'delivered',\n  'returned',\n  'cancelled',\n  'refunded'\n]);\nexport const paymentMethodEnum = pgEnum('payment_method', ['cod', 'online']);\nexport const negotiationStatusEnum = pgEnum('negotiation_status', ['pending', 'accepted', 'rejected']);\nexport const deliveryStatusEnum = pgEnum('delivery_status', ['pending', 'picked_up', 'in_transit', 'delivered', 'failed']);\nexport const verificationStatusEnum = pgEnum('verification_status', ['pending', 'approved', 'rejected']);\nexport const transactionTypeEnum = pgEnum('transaction_type', ['payment', 'refund', 'withdrawal', 'fee']);\nexport const transactionStatusEnum = pgEnum('transaction_status', ['pending', 'completed', 'failed', 'cancelled']);\nexport const notificationTypeEnum = pgEnum('notification_type', ['order_confirmation', 'rental_reminder', 'negotiation', 'system']);\nexport const rentalReturnStatusEnum = pgEnum('rental_return_status', ['pending', 'inspected', 'refunded', 'completed', 'rejected']);\nexport const withdrawalStatusEnum = pgEnum('withdrawal_status', ['pending', 'processed', 'rejected']);\n\nexport const adminConfigs = pgTable('admin_configs', {\n  key: text('key').primaryKey(),\n  value: text('value').notNull(),\n  description: text('description'),\n  updatedAt: timestamp('updated_at').notNull().defaultNow().$onUpdate(() => new Date()),\n});\n\nexport const categories = pgTable('categories', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n  slug: text('slug'),\n  description: text('description'),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow().$onUpdate(() => new Date()),\n  deletedAt: timestamp('deleted_at'),\n}, (table) => ({\n  nameIndex: uniqueIndex('categories_name_deleted_idx').on(table.name).where(sql`${table.deletedAt} IS NULL`),\n}));\n\nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n  email: text('email').notNull(),\n  passwordHash: text('password_hash').notNull(),\n  role: roleEnum('role').notNull().default('user'),\n  status: userStatusEnum('status').notNull().default('active'),\n  address: text('address'),\n  phone: text('phone'),\n  balance: decimal('balance', { precision: 14, scale: 2 }).notNull().default('0.00'),\n  nidFrontUrl: text('nid_front_url'),\n  nidBackUrl: text('nid_back_url'),\n  verificationStatus: verificationStatusEnum('verification_status').default('pending'),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow().$onUpdate(() => new Date()),\n  deletedAt: timestamp('deleted_at'),\n}, (table) => ({\n  emailIndex: uniqueIndex('users_email_deleted_idx').on(table.email).where(sql`${table.deletedAt} IS NULL`),\n  balanceCheck: check('users_balance_check', sql`${table.balance} >= 0`),\n}));\n\nexport const items = pgTable('items', {\n  id: serial('id').primaryKey(),\n  sellerId: integer('seller_id').notNull().references(() => users.id, { onDelete: 'cascade' }),\n  categoryId: integer('category_id').notNull().references(() => categories.id, { onDelete: 'restrict' }),\n  type: text('type').notNull(),\n  color: text('color'),\n  size: text('size'),\n  wearingTime: text('wearing_time'),\n  purchasePrice: decimal('purchase_price', { precision: 14, scale: 2 }).notNull(),\n  description: text('description').notNull(),\n  sellPrice: decimal('sell_price', { precision: 14, scale: 2 }),\n  rentPrice: decimal('rent_price', { precision: 14, scale: 2 }),\n  availability: itemAvailabilityEnum('availability').notNull(),\n  quantity: integer('quantity').notNull().default(1),\n  images: jsonb('images').notNull().$type<string[]>(),\n  video: text('video'),\n  status: itemStatusEnum('status').notNull().default('pending_approval'),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow().$onUpdate(() => new Date()),\n  deletedAt: timestamp('deleted_at'),\n}, (table) => ({\n  sellerIdx: index('items_seller_idx').on(table.sellerId),\n  categoryIdx: index('items_category_idx').on(table.categoryId),\n  statusIdx: index('items_status_idx').on(table.status),\n  availabilityIdx: index('items_availability_idx').on(table.availability),\n  typeIdx: index('items_type_idx').on(table.type),\n  colorIdx: index('items_color_idx').on(table.color),\n  sizeIdx: index('items_size_idx').on(table.size),\n  quantityCheck: check('items_quantity_check', sql`${table.quantity} >= 1`),\n  purchasePriceCheck: check('items_purchase_price_check', sql`${table.purchasePrice} >= 0`),\n  sellPriceCheck: check('items_sell_price_check', sql`${table.sellPrice} IS NULL OR ${table.sellPrice} >= 0`),\n  rentPriceCheck: check('items_rent_price_check', sql`${table.rentPrice} IS NULL OR ${table.rentPrice} >= 0`),\n}));\n\nexport const cartItems = pgTable('cart_items', {\n  id: serial('id').primaryKey(),\n  userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),\n  itemId: integer('item_id').notNull().references(() => items.id, { onDelete: 'cascade' }),\n  quantity: integer('quantity').notNull().default(1),\n  type: orderTypeEnum('type').notNull(),\n  negotiatedPrice: decimal('negotiated_price', { precision: 14, scale: 2 }),\n  negotiatedExpiresAt: timestamp('negotiated_expires_at'),\n  negotiationId: integer('negotiation_id').references(() => negotiations.id, { onDelete: 'set null' }),\n  addedAt: timestamp('added_at').notNull().defaultNow(),\n}, (table) => ({\n  uniqueIndex: uniqueIndex('cart_items_user_item_type_idx').on(table.userId, table.itemId, table.type),\n  userIdx: index('cart_items_user_idx').on(table.userId),\n  expiresIdx: index('cart_items_expires_idx').on(table.negotiatedExpiresAt),\n  quantityCheck: check('cart_items_quantity_check', sql`${table.quantity} >= 1`),\n}));\n\nexport const orders = pgTable('orders', {\n  id: serial('id').primaryKey(),\n  buyerId: integer('buyer_id').notNull().references(() => users.id, { onDelete: 'restrict' }),\n  totalAmount: decimal('total_amount', { precision: 14, scale: 2 }).notNull(),\n  deliveryCharge: decimal('delivery_charge', { precision: 14, scale: 2 }).notNull(),\n  safetyDeposit: decimal('safety_deposit', { precision: 14, scale: 2 }).default('0.00'),\n  paymentMethod: paymentMethodEnum('payment_method').notNull(),\n  status: orderStatusEnum('status').notNull().default('pending'),\n  paymentDueAt: timestamp('payment_due_at'),\n  deliveryChargePaid: boolean('delivery_charge_paid').notNull().default(false),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow().$onUpdate(() => new Date()),\n  deletedAt: timestamp('deleted_at'),\n}, (table) => ({\n  buyerIdx: index('orders_buyer_idx').on(table.buyerId),\n  statusIdx: index('orders_status_idx').on(table.status),\n  paymentDueIdx: index('orders_payment_due_idx').on(table.paymentDueAt),\n  totalCheck: check('orders_total_check', sql`${table.totalAmount} >= 0`),\n  deliveryChargeCheck: check('orders_delivery_charge_check', sql`${table.deliveryCharge} >= 0`),\n  depositCheck: check('orders_deposit_check', sql`${table.safetyDeposit} >= 0`),\n}));\n\nexport const orderItems = pgTable('order_items', {\n  id: serial('id').primaryKey(),\n  orderId: integer('order_id').notNull().references(() => orders.id, { onDelete: 'cascade' }),\n  itemId: integer('item_id').notNull().references(() => items.id, { onDelete: 'restrict' }),\n  quantity: integer('quantity').notNull(),\n  price: decimal('price', { precision: 14, scale: 2 }).notNull(),\n  type: orderTypeEnum('type').notNull(),\n  status: orderItemStatusEnum('status').notNull().default('pending'),\n}, (table) => ({\n  orderIdx: index('order_items_order_idx').on(table.orderId),\n  itemIdx: index('order_items_item_idx').on(table.itemId),\n  quantityCheck: check('order_items_quantity_check', sql`${table.quantity} >= 1`),\n  priceCheck: check('order_items_price_check', sql`${table.price} >= 0`),\n}));\n\nexport const negotiations = pgTable('negotiations', {\n  id: serial('id').primaryKey(),\n  itemId: integer('item_id').notNull().references(() => items.id, { onDelete: 'cascade' }),\n  buyerId: integer('buyer_id').notNull().references(() => users.id, { onDelete: 'cascade' }),\n  offerPrice: decimal('offer_price', { precision: 14, scale: 2 }).notNull(),\n  status: negotiationStatusEnum('status').notNull().default('pending'),\n  expiresAt: timestamp('expires_at'),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow().$onUpdate(() => new Date()),\n  deletedAt: timestamp('deleted_at'),\n}, (table) => ({\n  itemIdx: index('negotiations_item_idx').on(table.itemId),\n  buyerIdx: index('negotiations_buyer_idx').on(table.buyerId),\n  offerPriceCheck: check('negotiations_offer_price_check', sql`${table.offerPrice} >= 0`),\n}));\n\nexport const deliveries = pgTable('deliveries', {\n  id: serial('id').primaryKey(),\n  orderId: integer('order_id').notNull().references(() => orders.id, { onDelete: 'cascade' }),\n  fromAddress: text('from_address').notNull(),\n  toAddress: text('to_address').notNull(),\n  status: deliveryStatusEnum('status').notNull().default('pending'),\n  trackingId: text('tracking_id'),\n  isReturn: boolean('is_return').notNull().default(false),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow().$onUpdate(() => new Date()),\n  deletedAt: timestamp('deleted_at'),\n}, (table) => ({\n  orderIdx: index('deliveries_order_idx').on(table.orderId),\n  trackingIdx: index('deliveries_tracking_idx').on(table.trackingId),\n}));\n\nexport const rentals = pgTable('rentals', {\n  id: serial('id').primaryKey(),\n  orderItemId: integer('order_item_id').notNull().references(() => orderItems.id, { onDelete: 'cascade' }).unique(),\n  rentalStart: timestamp('rental_start').notNull(),\n  rentalEnd: timestamp('rental_end').notNull(),\n  returnStatus: rentalReturnStatusEnum('return_status').default('pending'),\n  inspectionResult: text('inspection_result'),\n  refundAmount: decimal('refund_amount', { precision: 14, scale: 2 }),\n  lateFee: decimal('late_fee', { precision: 14, scale: 2 }).notNull().default('0.00'),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  updatedAt: timestamp('updated_at').notNull().defaultNow().$onUpdate(() => new Date()),\n  deletedAt: timestamp('deleted_at'),\n}, (table) => ({\n  orderItemIdx: index('rentals_order_item_idx').on(table.orderItemId),\n  lateFeeCheck: check('rentals_late_fee_check', sql`${table.lateFee} >= 0`),\n  refundCheck: check('rentals_refund_check', sql`${table.refundAmount} IS NULL OR ${table.refundAmount} >= 0`),\n}));\n\nexport const transactions = pgTable('transactions', {\n  id: serial('id').primaryKey(),\n  userId: integer('user_id').references(() => users.id, { onDelete: 'restrict' }),\n  orderId: integer('order_id').references(() => orders.id, { onDelete: 'restrict' }),\n  amount: decimal('amount', { precision: 14, scale: 2 }).notNull(),\n  type: transactionTypeEnum('type').notNull(),\n  status: transactionStatusEnum('status').notNull().default('pending'),\n  description: text('description'),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  deletedAt: timestamp('deleted_at'),\n}, (table) => ({\n  userIdx: index('transactions_user_idx').on(table.userId),\n  orderIdx: index('transactions_order_idx').on(table.orderId),\n  typeIdx: index('transactions_type_idx').on(table.type),\n}));\n\nexport const withdrawalRequests = pgTable('withdrawal_requests', {\n  id: serial('id').primaryKey(),\n  userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),\n  amount: decimal('amount', { precision: 14, scale: 2 }).notNull(),\n  status: withdrawalStatusEnum('status').notNull().default('pending'),\n  processedAt: timestamp('processed_at'),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  deletedAt: timestamp('deleted_at'),\n}, (table) => ({\n  userIdx: index('withdrawal_requests_user_idx').on(table.userId),\n  amountCheck: check('withdrawal_requests_amount_check', sql`${table.amount} > 0`),\n}));\n\nexport const notifications = pgTable('notifications', {\n  id: serial('id').primaryKey(),\n  userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),\n  type: notificationTypeEnum('type').notNull(),\n  message: text('message').notNull(),\n  isRead: boolean('is_read').notNull().default(false),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n  deletedAt: timestamp('deleted_at'),\n}, (table) => ({\n  userIdx: index('notifications_user_idx').on(table.userId),\n}));\n\nexport const warehouseInventory = pgTable('warehouse_inventory', {\n  id: serial('id').primaryKey(),\n  itemId: integer('item_id').notNull().references(() => items.id, { onDelete: 'cascade' }),\n  quantity: integer('quantity').notNull().default(1),\n  status: itemStatusEnum('status').notNull().default('in_warehouse'),\n  lastUpdated: timestamp('last_updated').notNull().defaultNow().$onUpdate(() => new Date()),\n  deletedAt: timestamp('deleted_at'),\n}, (table) => ({\n  itemIdx: index('warehouse_inventory_item_idx').on(table.itemId),\n  quantityCheck: check('warehouse_inventory_quantity_check', sql`${table.quantity} >= 1`),\n}));\n\nexport const usersRelations = relations(users, ({ many }) => ({\n  items: many(items),\n  cartItems: many(cartItems),\n  orders: many(orders),\n  negotiations: many(negotiations),\n  transactions: many(transactions),\n  withdrawalRequests: many(withdrawalRequests),\n  notifications: many(notifications),\n}));\n\nexport const categoriesRelations = relations(categories, ({ many }) => ({\n  items: many(items),\n}));\n\nexport const itemsRelations = relations(items, ({ one, many }) => ({\n  seller: one(users, { fields: [items.sellerId], references: [users.id] }),\n  category: one(categories, { fields: [items.categoryId], references: [categories.id] }),\n  cartItems: many(cartItems),\n  orderItems: many(orderItems),\n  negotiations: many(negotiations),\n  warehouseInventory: many(warehouseInventory),\n}));\n\nexport const cartItemsRelations = relations(cartItems, ({ one }) => ({\n  user: one(users, { fields: [cartItems.userId], references: [users.id] }),\n  item: one(items, { fields: [cartItems.itemId], references: [items.id] }),\n  negotiation: one(negotiations, { fields: [cartItems.negotiationId], references: [negotiations.id] }),\n}));\n\nexport const ordersRelations = relations(orders, ({ one, many }) => ({\n  buyer: one(users, { fields: [orders.buyerId], references: [users.id] }),\n  orderItems: many(orderItems),\n  deliveries: many(deliveries),\n  transactions: many(transactions),\n}));\n\nexport const orderItemsRelations = relations(orderItems, ({ one }) => ({\n  order: one(orders, { fields: [orderItems.orderId], references: [orders.id] }),\n  item: one(items, { fields: [orderItems.itemId], references: [items.id] }),\n  rental: one(rentals, { fields: [orderItems.id], references: [rentals.orderItemId] }),\n}));\n\nexport const negotiationsRelations = relations(negotiations, ({ one }) => ({\n  item: one(items, { fields: [negotiations.itemId], references: [items.id] }),\n  buyer: one(users, { fields: [negotiations.buyerId], references: [users.id] }),\n}));\n\nexport const deliveriesRelations = relations(deliveries, ({ one }) => ({\n  order: one(orders, { fields: [deliveries.orderId], references: [orders.id] }),\n}));\n\nexport const rentalsRelations = relations(rentals, ({ one }) => ({\n  orderItem: one(orderItems, { fields: [rentals.orderItemId], references: [orderItems.id] }),\n}));\n\nexport const transactionsRelations = relations(transactions, ({ one }) => ({\n  user: one(users, { fields: [transactions.userId], references: [users.id] }),\n  order: one(orders, { fields: [transactions.orderId], references: [orders.id] }),\n}));\n\nexport const withdrawalRequestsRelations = relations(withdrawalRequests, ({ one }) => ({\n  user: one(users, { fields: [withdrawalRequests.userId], references: [users.id] }),\n}));\n\nexport const notificationsRelations = relations(notifications, ({ one }) => ({\n  user: one(users, { fields: [notifications.userId], references: [users.id] }),\n}));\n\nexport const warehouseInventoryRelations = relations(warehouseInventory, ({ one }) => ({\n  item: one(items, { fields: [warehouseInventory.itemId], references: [items.id] }),\n}));\n","size_bytes":17171},"src/middleware/auth.ts":{"content":"import { Response, NextFunction } from 'express';\nimport { AuthRequest, AuthUser } from '../types';\nimport { UnauthorizedError, ForbiddenError } from '../utils/error';\nimport { authService } from '../services/auth';\nimport { db } from '../db';\nimport { users } from '../db/schema';\nimport { eq, isNull } from 'drizzle-orm';\n\nexport const authenticate = async (\n  req: AuthRequest,\n  res: Response,\n  next: NextFunction\n) => {\n  try {\n    const authHeader = req.headers.authorization;\n\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      throw new UnauthorizedError('No token provided');\n    }\n\n    const token = authHeader.substring(7);\n    const decoded = authService.verifyToken(token);\n\n    const [user] = await db\n      .select({\n        id: users.id,\n        email: users.email,\n        role: users.role,\n        status: users.status,\n      })\n      .from(users)\n      .where(eq(users.id, decoded.userId))\n      .limit(1);\n\n    if (!user || user.status === 'deleted') {\n      throw new UnauthorizedError('User not found or deleted');\n    }\n\n    if (user.status === 'suspended') {\n      throw new ForbiddenError('Your account has been suspended');\n    }\n\n    if (user.status !== 'active') {\n      throw new ForbiddenError('Your account is not active');\n    }\n\n    req.user = user as AuthUser;\n    next();\n  } catch (error) {\n    next(error);\n  }\n};\n\nexport const authorize = (...roles: string[]) => {\n  return (req: AuthRequest, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return next(new UnauthorizedError('Authentication required'));\n    }\n\n    if (!roles.includes(req.user.role)) {\n      return next(new ForbiddenError('Insufficient permissions'));\n    }\n\n    next();\n  };\n};\n","size_bytes":1720},"src/middleware/errorHandler.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { AppError } from '../utils/error';\nimport { AuthRequest } from '../types';\nimport { env } from '../config/env';\n\nexport const errorHandler = (\n  err: Error,\n  req: AuthRequest,\n  res: Response,\n  next: NextFunction\n) => {\n  console.error(`[${req.requestId}] Error:`, err);\n\n  if (err instanceof AppError) {\n    return res.status(err.statusCode).json({\n      success: false,\n      error: err.message,\n      requestId: req.requestId,\n      ...(env.NODE_ENV === 'development' && { stack: err.stack }),\n    });\n  }\n\n  return res.status(500).json({\n    success: false,\n    error: 'Internal server error',\n    requestId: req.requestId,\n    ...(env.NODE_ENV === 'development' && { details: err.message, stack: err.stack }),\n  });\n};\n\nexport const notFoundHandler = (req: AuthRequest, res: Response) => {\n  res.status(404).json({\n    success: false,\n    error: 'Route not found',\n    requestId: req.requestId,\n  });\n};\n","size_bytes":978},"src/middleware/requestId.ts":{"content":"import { Response, NextFunction } from 'express';\nimport { v4 as uuidv4 } from 'uuid';\nimport { AuthRequest } from '../types';\n\nexport const requestIdMiddleware = (\n  req: AuthRequest,\n  res: Response,\n  next: NextFunction\n) => {\n  req.requestId = uuidv4();\n  res.setHeader('X-Request-ID', req.requestId);\n  next();\n};\n","size_bytes":319},"src/middleware/validation.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { ZodSchema, ZodError } from 'zod';\nimport { ValidationError } from '../utils/error';\n\nexport const validate = (schema: ZodSchema) => {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      await schema.parseAsync({\n        body: req.body,\n        query: req.query,\n        params: req.params,\n      });\n      next();\n    } catch (error) {\n      if (error instanceof ZodError) {\n        const messages = error.issues.map((e: any) => `${e.path.join('.')}: ${e.message}`);\n        next(new ValidationError(messages.join(', ')));\n      } else {\n        next(error);\n      }\n    }\n  };\n};\n","size_bytes":683},"src/routes/admin.routes.ts":{"content":"import { Router } from 'express';\nimport { AdminController } from '../controllers/admin.controller';\nimport { authenticate, authorize } from '../middleware/auth';\n\nconst router = Router();\nconst adminController = new AdminController();\n\nrouter.use(authenticate, authorize('admin'));\n\nrouter.get('/configs', adminController.getAllConfigs);\nrouter.get('/configs/:key', adminController.getConfig);\nrouter.put('/configs/:key', adminController.updateConfig);\n\nexport default router;\n","size_bytes":478},"src/routes/auth.routes.ts":{"content":"import { Router } from 'express';\nimport { AuthController } from '../controllers/auth.controller';\nimport { validate } from '../middleware/validation';\nimport { authenticate } from '../middleware/auth';\nimport { registerSchema, loginSchema } from '../validations/auth.validation';\n\nconst router = Router();\nconst authController = new AuthController();\n\nrouter.post('/register', validate(registerSchema), authController.register);\nrouter.post('/login', validate(loginSchema), authController.login);\nrouter.get('/profile', authenticate, authController.getProfile);\n\nexport default router;\n","size_bytes":587},"src/routes/cart.routes.ts":{"content":"import { Router } from 'express';\nimport { CartController } from '../controllers/cart.controller';\nimport { validate } from '../middleware/validation';\nimport { authenticate } from '../middleware/auth';\nimport {\n  addToCartSchema,\n  updateCartItemSchema,\n  removeFromCartSchema,\n} from '../validations/cart.validation';\n\nconst router = Router();\nconst cartController = new CartController();\n\nrouter.use(authenticate);\n\nrouter.get('/', cartController.getCart);\nrouter.post('/', validate(addToCartSchema), cartController.addItem);\nrouter.put('/:id', validate(updateCartItemSchema), cartController.updateItem);\nrouter.delete('/:id', validate(removeFromCartSchema), cartController.removeItem);\nrouter.delete('/', cartController.clearCart);\n\nexport default router;\n","size_bytes":760},"src/routes/category.routes.ts":{"content":"import { Router } from 'express';\nimport { CategoryController } from '../controllers/category.controller';\nimport { validate } from '../middleware/validation';\nimport { authenticate, authorize } from '../middleware/auth';\nimport {\n  createCategorySchema,\n  updateCategorySchema,\n  getCategorySchema,\n} from '../validations/category.validation';\n\nconst router = Router();\nconst categoryController = new CategoryController();\n\nrouter.get('/', categoryController.list);\nrouter.get('/:id', validate(getCategorySchema), categoryController.getById);\n\nrouter.use(authenticate, authorize('admin'));\n\nrouter.post('/', validate(createCategorySchema), categoryController.create);\nrouter.put('/:id', validate(updateCategorySchema), categoryController.update);\nrouter.delete('/:id', validate(getCategorySchema), categoryController.delete);\n\nexport default router;\n","size_bytes":851},"src/routes/health.routes.ts":{"content":"import { Router, Request, Response } from 'express';\nimport { db } from '../db';\nimport { sql } from 'drizzle-orm';\n\nconst router = Router();\n\nrouter.get('/health', async (req: Request, res: Response) => {\n  try {\n    await db.execute(sql`SELECT 1`);\n    \n    res.json({\n      success: true,\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n    });\n  } catch (error) {\n    res.status(503).json({\n      success: false,\n      status: 'unhealthy',\n      error: 'Database connection failed',\n    });\n  }\n});\n\nrouter.get('/health/ready', async (req: Request, res: Response) => {\n  try {\n    await db.execute(sql`SELECT 1`);\n    res.json({\n      success: true,\n      status: 'ready',\n    });\n  } catch (error) {\n    res.status(503).json({\n      success: false,\n      status: 'not ready',\n    });\n  }\n});\n\nrouter.get('/health/live', (req: Request, res: Response) => {\n  res.json({\n    success: true,\n    status: 'alive',\n  });\n});\n\nexport default router;\n","size_bytes":999},"src/routes/index.ts":{"content":"import { Router } from 'express';\nimport healthRoutes from './health.routes';\nimport authRoutes from './auth.routes';\nimport adminRoutes from './admin.routes';\nimport categoryRoutes from './category.routes';\nimport itemRoutes from './item.routes';\nimport cartRoutes from './cart.routes';\nimport orderRoutes from './order.routes';\nimport negotiationRoutes from './negotiation.routes';\nimport notificationRoutes from './notification.routes';\nimport transactionRoutes from './transaction.routes';\n\nconst router = Router();\n\nrouter.use('/', healthRoutes);\nrouter.use('/auth', authRoutes);\nrouter.use('/admin', adminRoutes);\nrouter.use('/categories', categoryRoutes);\nrouter.use('/items', itemRoutes);\nrouter.use('/cart', cartRoutes);\nrouter.use('/orders', orderRoutes);\nrouter.use('/negotiations', negotiationRoutes);\nrouter.use('/notifications', notificationRoutes);\nrouter.use('/transactions', transactionRoutes);\n\nexport default router;\n","size_bytes":936},"src/routes/item.routes.ts":{"content":"import { Router } from 'express';\nimport { ItemController } from '../controllers/item.controller';\nimport { validate } from '../middleware/validation';\nimport { authenticate, authorize } from '../middleware/auth';\nimport { createItemSchema, updateItemSchema } from '../validations/item.validation';\n\nconst router = Router();\nconst itemController = new ItemController();\n\nrouter.get('/', itemController.list);\nrouter.get('/:id', itemController.getById);\n\nrouter.use(authenticate);\n\nrouter.post('/', validate(createItemSchema), itemController.create);\nrouter.put('/:id', validate(updateItemSchema), itemController.update);\nrouter.delete('/:id', itemController.delete);\n\nrouter.put('/:id/status', authorize('admin'), itemController.updateStatus);\n\nexport default router;\n","size_bytes":768},"src/routes/negotiation.routes.ts":{"content":"import { Router } from 'express';\nimport { NegotiationController } from '../controllers/negotiation.controller';\nimport { validate } from '../middleware/validation';\nimport { authenticate } from '../middleware/auth';\nimport {\n  createNegotiationSchema,\n  respondToNegotiationSchema,\n} from '../validations/negotiation.validation';\n\nconst router = Router();\nconst negotiationController = new NegotiationController();\n\nrouter.use(authenticate);\n\nrouter.get('/', negotiationController.list);\nrouter.get('/:id', negotiationController.getById);\nrouter.post('/', validate(createNegotiationSchema), negotiationController.create);\nrouter.put('/:id/respond', validate(respondToNegotiationSchema), negotiationController.respond);\n\nexport default router;\n","size_bytes":744},"src/routes/notification.routes.ts":{"content":"import { Router } from 'express';\nimport { NotificationController } from '../controllers/notification.controller';\nimport { authenticate } from '../middleware/auth';\n\nconst router = Router();\nconst notificationController = new NotificationController();\n\nrouter.use(authenticate);\n\nrouter.get('/', notificationController.list);\nrouter.put('/:id/read', notificationController.markAsRead);\nrouter.put('/read-all', notificationController.markAllAsRead);\n\nexport default router;\n","size_bytes":474},"src/routes/order.routes.ts":{"content":"import { Router } from 'express';\nimport { OrderController } from '../controllers/order.controller';\nimport { validate } from '../middleware/validation';\nimport { authenticate, authorize } from '../middleware/auth';\nimport { createOrderSchema, updateOrderStatusSchema } from '../validations/order.validation';\n\nconst router = Router();\nconst orderController = new OrderController();\n\nrouter.use(authenticate);\n\nrouter.get('/', orderController.list);\nrouter.get('/:id', orderController.getById);\nrouter.post('/', validate(createOrderSchema), orderController.create);\nrouter.put('/:id/status', authorize('admin'), validate(updateOrderStatusSchema), orderController.updateStatus);\n\nexport default router;\n","size_bytes":702},"src/routes/transaction.routes.ts":{"content":"import { Router } from 'express';\nimport { TransactionController } from '../controllers/transaction.controller';\nimport { authenticate } from '../middleware/auth';\n\nconst router = Router();\nconst transactionController = new TransactionController();\n\nrouter.use(authenticate);\n\nrouter.get('/', transactionController.list);\nrouter.post('/withdraw', transactionController.requestWithdrawal);\nrouter.get('/withdrawals', transactionController.getWithdrawals);\n\nexport default router;\n","size_bytes":479},"src/scripts/seed.ts":{"content":"import { db } from '../db';\nimport { adminConfigs, users } from '../db/schema';\nimport { eq } from 'drizzle-orm';\nimport { authService } from '../services/auth';\nimport { env } from '../config/env';\n\nasync function seed() {\n  try {\n    console.log('🌱 Seeding database...');\n\n    const defaultConfigs = [\n      {\n        key: 'delivery_charge_per_order',\n        value: '100.00',\n        description: 'Delivery charge per order (in TK)',\n      },\n      {\n        key: 'safety_deposit_percentage',\n        value: '30',\n        description: 'Safety deposit percentage for rentals',\n      },\n      {\n        key: 'rental_period_days',\n        value: '7',\n        description: 'Default rental period in days',\n      },\n      {\n        key: 'platform_fee_sale_percent',\n        value: '8',\n        description: 'Platform fee percentage for sales',\n      },\n      {\n        key: 'platform_fee_rental_percent',\n        value: '16',\n        description: 'Platform fee percentage for rentals',\n      },\n      {\n        key: 'negotiation_hold_minutes',\n        value: '1440',\n        description: 'Hold time for negotiated prices in cart (in minutes)',\n      },\n      {\n        key: 'payment_timeout_minutes',\n        value: '1440',\n        description: 'Payment timeout for orders (in minutes)',\n      },\n    ];\n\n    for (const config of defaultConfigs) {\n      const [existing] = await db\n        .select()\n        .from(adminConfigs)\n        .where(eq(adminConfigs.key, config.key))\n        .limit(1);\n\n      if (!existing) {\n        await db.insert(adminConfigs).values(config);\n        console.log(`✓ Created config: ${config.key}`);\n      } else {\n        console.log(`- Config already exists: ${config.key}`);\n      }\n    }\n\n    const [existingAdmin] = await db\n      .select()\n      .from(users)\n      .where(eq(users.email, env.ADMIN_EMAIL))\n      .limit(1);\n\n    if (!existingAdmin) {\n      const passwordHash = await authService.hashPassword(env.ADMIN_PASSWORD);\n      \n      await db.insert(users).values({\n        name: 'Admin',\n        email: env.ADMIN_EMAIL,\n        passwordHash,\n        role: 'admin',\n        status: 'active',\n        verificationStatus: 'approved',\n      });\n\n      console.log(`✓ Created admin user: ${env.ADMIN_EMAIL}`);\n    } else {\n      console.log(`- Admin user already exists: ${env.ADMIN_EMAIL}`);\n    }\n\n    console.log('✅ Seeding completed!');\n    process.exit(0);\n  } catch (error) {\n    console.error('❌ Seeding failed:', error);\n    process.exit(1);\n  }\n}\n\nseed();\n","size_bytes":2514},"src/types/index.ts":{"content":"import { Request } from 'express';\n\nexport interface AuthUser {\n  id: number;\n  email: string;\n  role: 'user' | 'seller' | 'user_seller' | 'admin';\n  status: 'active' | 'inactive' | 'deleted' | 'suspended';\n}\n\nexport interface AuthRequest extends Request {\n  user?: AuthUser;\n  requestId?: string;\n}\n\nexport interface PaginationParams {\n  page?: number;\n  limit?: number;\n}\n\nexport interface FilterParams {\n  categoryId?: number;\n  type?: string;\n  color?: string;\n  size?: string;\n  minPrice?: number;\n  maxPrice?: number;\n  wearingTime?: string;\n  status?: string;\n  availability?: string;\n}\n\nexport interface ApiResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  message?: string;\n  requestId?: string;\n}\n\nexport interface PaginatedResponse<T> extends ApiResponse<T> {\n  pagination?: {\n    page: number;\n    limit: number;\n    total: number;\n    totalPages: number;\n  };\n}\n","size_bytes":897},"src/utils/error.ts":{"content":"export class AppError extends Error {\n  public statusCode: number;\n  public isOperational: boolean;\n\n  constructor(message: string, statusCode: number = 500, isOperational: boolean = true) {\n    super(message);\n    this.statusCode = statusCode;\n    this.isOperational = isOperational;\n\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(message: string) {\n    super(message, 400);\n  }\n}\n\nexport class UnauthorizedError extends AppError {\n  constructor(message: string = 'Unauthorized') {\n    super(message, 401);\n  }\n}\n\nexport class ForbiddenError extends AppError {\n  constructor(message: string = 'Forbidden') {\n    super(message, 403);\n  }\n}\n\nexport class NotFoundError extends AppError {\n  constructor(message: string = 'Resource not found') {\n    super(message, 404);\n  }\n}\n\nexport class ConflictError extends AppError {\n  constructor(message: string) {\n    super(message, 409);\n  }\n}\n","size_bytes":961},"src/validations/auth.validation.ts":{"content":"import { z } from 'zod';\n\nexport const registerSchema = z.object({\n  body: z.object({\n    name: z.string().min(2, 'Name must be at least 2 characters'),\n    email: z.string().email('Invalid email address'),\n    password: z.string().min(6, 'Password must be at least 6 characters'),\n    address: z.string().optional(),\n    phone: z.string().optional(),\n  }),\n});\n\nexport const loginSchema = z.object({\n  body: z.object({\n    email: z.string().email('Invalid email address'),\n    password: z.string().min(1, 'Password is required'),\n  }),\n});\n\nexport const uploadNIDSchema = z.object({\n  body: z.object({\n    side: z.enum(['front', 'back']),\n  }),\n});\n","size_bytes":650},"src/validations/cart.validation.ts":{"content":"import { z } from 'zod';\n\nexport const addToCartSchema = z.object({\n  body: z.object({\n    itemId: z.number().int().positive(),\n    quantity: z.number().int().positive().default(1),\n    type: z.enum(['buy', 'rent']),\n  }),\n});\n\nexport const updateCartItemSchema = z.object({\n  params: z.object({\n    id: z.string().transform(Number),\n  }),\n  body: z.object({\n    quantity: z.number().int().positive(),\n  }),\n});\n\nexport const removeFromCartSchema = z.object({\n  params: z.object({\n    id: z.string().transform(Number),\n  }),\n});\n","size_bytes":529},"src/validations/category.validation.ts":{"content":"import { z } from 'zod';\n\nexport const createCategorySchema = z.object({\n  body: z.object({\n    name: z.string().min(2, 'Name must be at least 2 characters'),\n    slug: z.string().optional(),\n    description: z.string().optional(),\n  }),\n});\n\nexport const updateCategorySchema = z.object({\n  params: z.object({\n    id: z.string().transform(Number),\n  }),\n  body: z.object({\n    name: z.string().min(2).optional(),\n    slug: z.string().optional(),\n    description: z.string().optional(),\n  }),\n});\n\nexport const getCategorySchema = z.object({\n  params: z.object({\n    id: z.string().transform(Number),\n  }),\n});\n","size_bytes":611},"src/validations/item.validation.ts":{"content":"import { z } from 'zod';\n\nexport const createItemSchema = z.object({\n  body: z.object({\n    categoryId: z.number().int().positive(),\n    type: z.string().min(1),\n    color: z.string().optional(),\n    size: z.string().optional(),\n    wearingTime: z.string().optional(),\n    purchasePrice: z.number().nonnegative(),\n    description: z.string().min(10),\n    sellPrice: z.number().nonnegative().optional(),\n    rentPrice: z.number().nonnegative().optional(),\n    availability: z.enum(['sell_only', 'rent_only', 'both']),\n    quantity: z.number().int().positive().default(1),\n    images: z.array(z.string()).min(1).max(5),\n    video: z.string().optional(),\n  }),\n});\n\nexport const updateItemSchema = z.object({\n  params: z.object({\n    id: z.string().transform(Number),\n  }),\n  body: z.object({\n    type: z.string().min(1).optional(),\n    color: z.string().optional(),\n    size: z.string().optional(),\n    wearingTime: z.string().optional(),\n    purchasePrice: z.number().nonnegative().optional(),\n    description: z.string().min(10).optional(),\n    sellPrice: z.number().nonnegative().optional(),\n    rentPrice: z.number().nonnegative().optional(),\n    availability: z.enum(['sell_only', 'rent_only', 'both']).optional(),\n    quantity: z.number().int().positive().optional(),\n    images: z.array(z.string()).min(1).max(5).optional(),\n    video: z.string().optional(),\n  }),\n});\n","size_bytes":1374},"src/validations/negotiation.validation.ts":{"content":"import { z } from 'zod';\n\nexport const createNegotiationSchema = z.object({\n  body: z.object({\n    itemId: z.number().int().positive(),\n    offerPrice: z.number().positive(),\n    expiresAt: z.string().datetime().optional(),\n  }),\n});\n\nexport const respondToNegotiationSchema = z.object({\n  params: z.object({\n    id: z.string().transform(Number),\n  }),\n  body: z.object({\n    status: z.enum(['accepted', 'rejected']),\n  }),\n});\n","size_bytes":428},"src/validations/order.validation.ts":{"content":"import { z } from 'zod';\n\nexport const createOrderSchema = z.object({\n  body: z.object({\n    paymentMethod: z.enum(['cod', 'online']),\n    deliveryAddress: z.string().min(10),\n  }),\n});\n\nexport const updateOrderStatusSchema = z.object({\n  params: z.object({\n    id: z.string().transform(Number),\n  }),\n  body: z.object({\n    status: z.enum(['pending', 'paid', 'shipped', 'delivered', 'returned', 'partially_returned', 'cancelled', 'refunded']),\n  }),\n});\n","size_bytes":455},"src/services/auth/authService.interface.ts":{"content":"export interface IAuthService {\n  generateToken(payload: { userId: number; email: string; role: string }): string;\n  verifyToken(token: string): { userId: number; email: string; role: string };\n  hashPassword(password: string): Promise<string>;\n  comparePassword(password: string, hash: string): Promise<boolean>;\n}\n","size_bytes":316},"src/services/auth/index.ts":{"content":"import { IAuthService } from './authService.interface';\nimport { JWTAuthService } from './jwtAuthService';\n\nexport const authService: IAuthService = new JWTAuthService();\n\nexport { IAuthService };\n","size_bytes":197},"src/services/auth/jwtAuthService.ts":{"content":"import jwt from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\nimport { env } from '../../config/env';\nimport { IAuthService } from './authService.interface';\nimport { UnauthorizedError } from '../../utils/error';\n\nexport class JWTAuthService implements IAuthService {\n  generateToken(payload: { userId: number; email: string; role: string }): string {\n    return jwt.sign(payload, env.JWT_SECRET, { expiresIn: env.JWT_EXPIRES_IN } as jwt.SignOptions);\n  }\n\n  verifyToken(token: string): { userId: number; email: string; role: string } {\n    try {\n      const decoded = jwt.verify(token, env.JWT_SECRET) as any;\n      return {\n        userId: decoded.userId,\n        email: decoded.email,\n        role: decoded.role,\n      };\n    } catch (error) {\n      throw new UnauthorizedError('Invalid or expired token');\n    }\n  }\n\n  async hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, 12);\n  }\n\n  async comparePassword(password: string, hash: string): Promise<boolean> {\n    return bcrypt.compare(password, hash);\n  }\n}\n","size_bytes":1048},"src/services/delivery/deliveryService.interface.ts":{"content":"export interface DeliveryRequest {\n  orderId: number;\n  fromAddress: string;\n  toAddress: string;\n  contactPhone: string;\n  isReturn?: boolean;\n  itemDescription?: string;\n}\n\nexport interface DeliveryResponse {\n  success: boolean;\n  trackingId?: string;\n  estimatedDelivery?: Date;\n  error?: string;\n}\n\nexport interface DeliveryStatus {\n  trackingId: string;\n  status: 'pending' | 'picked_up' | 'in_transit' | 'delivered' | 'failed';\n  currentLocation?: string;\n  estimatedDelivery?: Date;\n}\n\nexport interface IDeliveryService {\n  createDelivery(request: DeliveryRequest): Promise<DeliveryResponse>;\n  getDeliveryStatus(trackingId: string): Promise<DeliveryStatus>;\n  cancelDelivery(trackingId: string): Promise<boolean>;\n}\n","size_bytes":724},"src/services/delivery/index.ts":{"content":"import { IDeliveryService } from './deliveryService.interface';\nimport { MockDeliveryService } from './mockDeliveryService';\n\nexport const deliveryService: IDeliveryService = new MockDeliveryService();\n\nexport { IDeliveryService };\n","size_bytes":232},"src/services/delivery/mockDeliveryService.ts":{"content":"import {\n  IDeliveryService,\n  DeliveryRequest,\n  DeliveryResponse,\n  DeliveryStatus,\n} from './deliveryService.interface';\n\nexport class MockDeliveryService implements IDeliveryService {\n  async createDelivery(request: DeliveryRequest): Promise<DeliveryResponse> {\n    console.log('[DeliveryService] Delivery would be created:', request);\n    \n    const trackingId = `TRK_${Date.now()}`;\n    const estimatedDelivery = new Date();\n    estimatedDelivery.setDate(estimatedDelivery.getDate() + 3);\n\n    return {\n      success: true,\n      trackingId,\n      estimatedDelivery,\n    };\n  }\n\n  async getDeliveryStatus(trackingId: string): Promise<DeliveryStatus> {\n    console.log('[DeliveryService] Getting delivery status:', trackingId);\n    \n    return {\n      trackingId,\n      status: 'in_transit',\n      currentLocation: 'Distribution Center',\n      estimatedDelivery: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000),\n    };\n  }\n\n  async cancelDelivery(trackingId: string): Promise<boolean> {\n    console.log('[DeliveryService] Delivery cancellation:', trackingId);\n    return true;\n  }\n}\n","size_bytes":1087},"src/services/jobs/inMemoryJobService.ts":{"content":"import { IJobService, JobOptions, RecurringJobOptions } from './jobService.interface';\n\nexport class InMemoryJobService implements IJobService {\n  private jobs: Map<string, any> = new Map();\n\n  async addJob<T = any>(\n    queueName: string,\n    jobName: string,\n    data: T,\n    options?: JobOptions\n  ): Promise<void> {\n    const jobId = `${queueName}:${jobName}:${Date.now()}`;\n    \n    console.log(`[InMemoryJobService] Job scheduled: ${jobId}`, {\n      queueName,\n      jobName,\n      data,\n      options,\n    });\n\n    this.jobs.set(jobId, { queueName, jobName, data, options, status: 'pending' });\n\n    if (options?.delay) {\n      setTimeout(() => {\n        console.log(`[InMemoryJobService] Job would execute now: ${jobId}`);\n      }, options.delay);\n    }\n  }\n\n  async addRecurringJob<T = any>(\n    queueName: string,\n    jobName: string,\n    data: T,\n    options: RecurringJobOptions\n  ): Promise<void> {\n    console.log(`[InMemoryJobService] Recurring job scheduled: ${queueName}:${jobName}`, {\n      data,\n      options,\n    });\n  }\n\n  async removeJob(queueName: string, jobId: string): Promise<void> {\n    this.jobs.delete(jobId);\n  }\n\n  async getJobStatus(queueName: string, jobId: string): Promise<string | null> {\n    const job = this.jobs.get(jobId);\n    return job ? job.status : null;\n  }\n}\n","size_bytes":1307},"src/services/jobs/index.ts":{"content":"import { IJobService } from './jobService.interface';\nimport { InMemoryJobService } from './inMemoryJobService';\n\nexport const jobService: IJobService = new InMemoryJobService();\n\nexport { IJobService };\n","size_bytes":204},"src/services/jobs/jobService.interface.ts":{"content":"export interface JobOptions {\n  delay?: number;\n  attempts?: number;\n  backoff?: {\n    type: 'fixed' | 'exponential';\n    delay: number;\n  };\n}\n\nexport interface RecurringJobOptions extends JobOptions {\n  cron?: string;\n  repeat?: {\n    every?: number;\n    limit?: number;\n  };\n}\n\nexport interface IJobService {\n  addJob<T = any>(queueName: string, jobName: string, data: T, options?: JobOptions): Promise<void>;\n  addRecurringJob<T = any>(\n    queueName: string,\n    jobName: string,\n    data: T,\n    options: RecurringJobOptions\n  ): Promise<void>;\n  removeJob(queueName: string, jobId: string): Promise<void>;\n  getJobStatus(queueName: string, jobId: string): Promise<string | null>;\n}\n","size_bytes":689},"src/services/notification/inAppNotificationService.ts":{"content":"import {\n  INotificationService,\n  EmailNotification,\n  SMSNotification,\n  InAppNotification,\n} from './notificationService.interface';\nimport { db } from '../../db';\nimport { notifications } from '../../db/schema';\n\nexport class InAppNotificationService implements INotificationService {\n  async sendEmail(notification: EmailNotification): Promise<void> {\n    console.log('[NotificationService] Email would be sent:', notification);\n  }\n\n  async sendSMS(notification: SMSNotification): Promise<void> {\n    console.log('[NotificationService] SMS would be sent:', notification);\n  }\n\n  async sendInApp(notification: InAppNotification): Promise<void> {\n    await db.insert(notifications).values({\n      userId: notification.userId,\n      type: notification.type,\n      message: notification.message,\n      isRead: false,\n    });\n  }\n\n  async sendRealTime(userId: number, event: string, data: any): Promise<void> {\n    console.log('[NotificationService] Real-time notification would be sent:', {\n      userId,\n      event,\n      data,\n    });\n  }\n}\n","size_bytes":1046},"src/services/notification/index.ts":{"content":"import { INotificationService } from './notificationService.interface';\nimport { InAppNotificationService } from './inAppNotificationService';\n\nexport const notificationService: INotificationService = new InAppNotificationService();\n\nexport { INotificationService };\n","size_bytes":267},"src/services/notification/notificationService.interface.ts":{"content":"export interface EmailNotification {\n  to: string;\n  subject: string;\n  text?: string;\n  html?: string;\n}\n\nexport interface SMSNotification {\n  to: string;\n  message: string;\n}\n\nexport interface InAppNotification {\n  userId: number;\n  type: 'order_confirmation' | 'rental_reminder' | 'negotiation' | 'system';\n  message: string;\n}\n\nexport interface INotificationService {\n  sendEmail(notification: EmailNotification): Promise<void>;\n  sendSMS(notification: SMSNotification): Promise<void>;\n  sendInApp(notification: InAppNotification): Promise<void>;\n  sendRealTime(userId: number, event: string, data: any): Promise<void>;\n}\n","size_bytes":626},"src/services/payment/index.ts":{"content":"import { IPaymentService } from './paymentService.interface';\nimport { MockPaymentService } from './mockPaymentService';\n\nexport const paymentService: IPaymentService = new MockPaymentService();\n\nexport { IPaymentService };\n","size_bytes":224},"src/services/payment/mockPaymentService.ts":{"content":"import {\n  IPaymentService,\n  PaymentRequest,\n  PaymentResponse,\n  RefundRequest,\n  RefundResponse,\n} from './paymentService.interface';\n\nexport class MockPaymentService implements IPaymentService {\n  async createPayment(request: PaymentRequest): Promise<PaymentResponse> {\n    console.log('[PaymentService] Payment would be created:', request);\n    \n    return {\n      success: true,\n      transactionId: `TXN_${Date.now()}`,\n      paymentUrl: `https://payment.example.com/pay/${request.orderId}`,\n    };\n  }\n\n  async verifyPayment(transactionId: string): Promise<boolean> {\n    console.log('[PaymentService] Payment verification:', transactionId);\n    return true;\n  }\n\n  async refundPayment(request: RefundRequest): Promise<RefundResponse> {\n    console.log('[PaymentService] Refund would be processed:', request);\n    \n    return {\n      success: true,\n      refundId: `REF_${Date.now()}`,\n    };\n  }\n}\n","size_bytes":907},"src/services/payment/paymentService.interface.ts":{"content":"export interface PaymentRequest {\n  orderId: number;\n  amount: number;\n  currency?: string;\n  description?: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface PaymentResponse {\n  success: boolean;\n  transactionId?: string;\n  paymentUrl?: string;\n  error?: string;\n}\n\nexport interface RefundRequest {\n  transactionId: string;\n  amount: number;\n  reason?: string;\n}\n\nexport interface RefundResponse {\n  success: boolean;\n  refundId?: string;\n  error?: string;\n}\n\nexport interface IPaymentService {\n  createPayment(request: PaymentRequest): Promise<PaymentResponse>;\n  verifyPayment(transactionId: string): Promise<boolean>;\n  refundPayment(request: RefundRequest): Promise<RefundResponse>;\n}\n","size_bytes":701},"src/services/storage/index.ts":{"content":"import { IStorageService } from './storageService.interface';\nimport { LocalStorageService } from './localStorageService';\n\nexport const storageService: IStorageService = new LocalStorageService();\n\nexport { IStorageService };\n","size_bytes":227},"src/services/storage/localStorageService.ts":{"content":"import fs from 'fs/promises';\nimport path from 'path';\nimport { v4 as uuidv4 } from 'uuid';\nimport { env } from '../../config/env';\nimport { IStorageService, UploadedFile, FileUpload } from './storageService.interface';\n\nexport class LocalStorageService implements IStorageService {\n  private baseDir: string;\n\n  constructor(baseDir: string = env.UPLOAD_DIR) {\n    this.baseDir = baseDir;\n    this.ensureBaseDir();\n  }\n\n  private async ensureBaseDir() {\n    try {\n      await fs.mkdir(this.baseDir, { recursive: true });\n    } catch (error) {\n      console.error('Failed to create upload directory:', error);\n    }\n  }\n\n  private async ensureDir(dirPath: string) {\n    try {\n      await fs.mkdir(dirPath, { recursive: true });\n    } catch (error) {\n      console.error('Failed to create directory:', error);\n    }\n  }\n\n  async uploadFile(file: FileUpload, folder: string = ''): Promise<UploadedFile> {\n    const targetDir = path.join(this.baseDir, folder);\n    await this.ensureDir(targetDir);\n\n    const ext = path.extname(file.originalname);\n    const fileName = `${uuidv4()}${ext}`;\n    const filePath = path.join(targetDir, fileName);\n\n    await fs.writeFile(filePath, file.buffer);\n\n    return {\n      originalName: file.originalname,\n      fileName,\n      path: path.join(folder, fileName),\n      size: file.size,\n      mimetype: file.mimetype,\n    };\n  }\n\n  async uploadFiles(files: FileUpload[], folder: string = ''): Promise<UploadedFile[]> {\n    return Promise.all(files.map((file) => this.uploadFile(file, folder)));\n  }\n\n  async deleteFile(filePath: string): Promise<void> {\n    const fullPath = path.join(this.baseDir, filePath);\n    try {\n      await fs.unlink(fullPath);\n    } catch (error) {\n      console.error('Failed to delete file:', error);\n    }\n  }\n\n  getFileUrl(filePath: string): string {\n    return `/uploads/${filePath}`;\n  }\n\n  async getSignedUrl(filePath: string, expiresIn: number = 3600): Promise<string> {\n    return this.getFileUrl(filePath);\n  }\n}\n","size_bytes":1982},"src/services/storage/storageService.interface.ts":{"content":"export interface UploadedFile {\n  originalName: string;\n  fileName: string;\n  path: string;\n  size: number;\n  mimetype: string;\n}\n\nexport interface FileUpload {\n  originalname: string;\n  buffer: Buffer;\n  size: number;\n  mimetype: string;\n}\n\nexport interface IStorageService {\n  uploadFile(file: FileUpload, folder?: string): Promise<UploadedFile>;\n  uploadFiles(files: FileUpload[], folder?: string): Promise<UploadedFile[]>;\n  deleteFile(filePath: string): Promise<void>;\n  getFileUrl(filePath: string): string;\n  getSignedUrl(filePath: string, expiresIn?: number): Promise<string>;\n}\n","size_bytes":587}},"version":1}